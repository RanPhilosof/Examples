@page "/fetchdata"
@using Prober.Consumer.Service
@using RP.Prober.Singleton
@inject ProberCacheMonitoringService proberCacheMonitoringService
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject IJSRuntime JS

<PageTitle>Prober</PageTitle>

@* <button class="btn btn-secondary mb-2" @onclick="ToggleLogPopup">Show Console Logs</button> *@
<button class="btn mb-2 @(hasNewLogs ? "btn-danger" : "btn-secondary")" @onclick="ToggleLogPopup">
    Show Console Logs
</button>

@if (logPopupVisible)
{
    <div class="modal-backdrop fade show"></div>
    <div class="modal d-block" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Console Logs (Live)</h5>
                    <button type="button" class="btn-close" @onclick="ToggleLogPopup"></button>
                </div>

<div class="modal-body" style="max-height: 400px; overflow-y: auto;" @ref="logContainerRef">
    <div style="min-height: 400px;">
        @if (!liveLogs.Any())
        {
            <em>No logs yet.</em>
        }
        else
        {
@*             @foreach (var line in liveLogs.Select((text, i) => new { text, i }))
            {
                <div>
                    <code id="log-line-@line.i">@line.text</code>
                </div>
            } *@

                            @foreach (var line in liveLogs.Select((text, i) => new { text, i }))
                            {
                                <div>
                                    <pre id="log-line-@line.i" class="log-line" @onclick="() => SelectLogLine(line.i)">@line.text</pre>
                                </div>
                            }
        }
    </div>
</div>
                <div class="modal-footer">
                    <button class="btn btn-outline-primary me-2" @onclick="ToggleAutoScroll">
                        @(autoScrollEnabled ? "Pause Auto-Scroll" : "Resume Auto-Scroll")
                    </button>
                    <button class="btn btn-secondary" @onclick="ToggleLogPopup">Close</button>
                </div>
            </div>
        </div>
    </div>
}

<h4>Favorites</h4>

<input class="form-control mb-1" @bind="newFavoriteName" placeholder="New favorite name..." />
<button class="btn btn-primary mb-2" @onclick="SaveFavorites" disabled="@string.IsNullOrWhiteSpace(newFavoriteName)">Save Favorite</button>

@if (favorites?.Any() == true)
{
    <button class="btn btn-link mb-2" @onclick="ToggleFavoritesExpanded">
        @(favoritesExpanded ? "Hide Favorites ▼" : "Show Favorites ▶")
    </button>

    @if (favoritesExpanded)
    {
        <ul class="list-group mb-3">
            @foreach (var fav in favorites)
            {
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <span>
                        @fav.Name (@fav.SavedAt.ToShortTimeString())
                        @if (fav.IsDefault)
                        {
                            <span class="badge bg-success ms-2">Default</span>
                        }
                    </span>
                    <div>
                        <button class="btn btn-sm btn-outline-success me-1" @onclick="() => LoadFavorite(fav)">Load</button>
                        <button class="btn btn-sm btn-outline-secondary me-1" @onclick="() => ToggleDefaultFavorite(fav)">
                            @(fav.IsDefault ? "Unset Default" : "Set as Default")
                        </button>
                        <button class="btn btn-sm btn-outline-danger" @onclick="() => RemoveFavorite(fav)">Remove</button>
                    </div>
                </li>
            }
        </ul>
    }
}

<input class="form-control mb-2" value="@pendingFilterText" @oninput="OnNameFilterChanged" placeholder="Filter by name..." />
@* <input class="form-control mb-2" @bind="nameFilter" placeholder="Filter by name..." /> *@

<div class="mb-2">
    <input type="checkbox" class="form-check-input me-1" @bind="showOnlySelected" id="showSelectedToggle" />
    <label for="showSelectedToggle">Show only selected</label>
</div>

@if (tablesInfo == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Select</th>
                <th>AppName</th>
                <th>Name</th>
                <th>Guid</th>
                <th>Available</th>
                <th>Group Index</th> @* New column *@
            </tr>
        </thead>
        <tbody>
            @foreach (var tableInfo in tablesInfo.Where(t => (string.IsNullOrEmpty(nameFilter) || t.Name.Contains(nameFilter, StringComparison.OrdinalIgnoreCase)) && (!showOnlySelected || t.Capture)))
            {
                <tr>
                    <td>
                        <input type="checkbox" checked="@tableInfo.Capture" @onchange="(e => OnTableInfoChanged(tableInfo, e))" />
                    </td>
                    <td>@tableInfo.ApplicationName</td>
                    <td>@tableInfo.Name</td>
                    <td>@tableInfo.Guid</td>
                    <td>@tableInfo.Available</td>
                    <td>
                        <select class="form-select" @bind="tableInfo.GroupIndex">
                            <option value="-1">Default</option>
                            @for (int i = 0; i < 10; i++)
                            {
                                <option value="@i">Group @i</option>
                            }
                        </select>
                    </td>
                </tr>
            }
        </tbody>
    </table>

    <button class="btn btn-primary mb-2" @onclick="TogglePause">
        @(isPaused ? "Resume Refresh" : "Pause Refresh")
    </button>

    <style>
    .tabs {
        display: flex;
        border-bottom: 2px solid #ccc;
        margin-bottom: 1rem;
        cursor: pointer;
    }

    .tab {
        padding: 0.5rem 1rem;
        border: 1px solid #ccc;
        border-bottom: none;
        background-color: #f1f1f1;
        margin-right: 4px;
    }

    .tab.active {
        background-color: white;
        font-weight: bold;
        border-top: 2px solid #007bff;
        border-left: 1px solid #ccc;
        border-right: 1px solid #ccc;
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block;
    }

    .my-custom-table th,
    .my-custom-table td {
        border: 1px solid #ccc;
        padding: 0.5rem 1rem;
        text-align: left !important;
        white-space: nowrap;
        vertical-align: middle;
    }

    .my-custom-table {
        border-collapse: collapse;
        width: 100%;
    }
</style>

@* <div class="tabs" id="tab-buttons">
    @for (int i = 0; i < tablesData.Count; i++)
    {
            <div class="tab @(i == 0 ? "active" : "")" onclick="showTab(@i)">@tablesData[i].TableInfo.Name</div>
    }
</div> *@
    <div class="tabs" id="tab-buttons">
        @for (int i = 0; i < groupedTables.Count; i++)
        {
            var groupIndex = groupedTables.Keys.ElementAt(i);
            <div class="tab @(i == 0 ? "active" : "")" onclick="showTab(@i)">
                @(groupIndex == -1 ? "Default Group" : $"Group {groupIndex}")
            </div>
        }
    </div>

    @for (int i = 0; i < groupedTables.Count; i++)
    {
        var group = groupedTables.ElementAt(i);
        var groupIndex = group.Key;
        var tables = group.Value;

        <div class="tab-content @(i == 0 ? "active" : "")" id="tab-content-@i">            

            @foreach (var table in tables)
            {
                <div class="table-container mb-4">                    
                    <p>@table.TableInfo.Name (<strong>Guid:</strong> @table.TableInfo.Guid)</p>

                    <table class="my-custom-table">
                        <thead>
                            <tr>
                                @foreach (var header in table.TableData.FirstOrDefault() ?? new List<string>())
                                {
                                    <th>@header</th>
                                }
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var row in table.TableData.Skip(1))
                            {
                                <tr>
                                    @foreach (var cell in row)
                                    {
                                        <td>@cell</td>
                                    }
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    }

<script>
    function showTab(index) {
        const tabs = document.querySelectorAll('.tab');
        const contents = document.querySelectorAll('.tab-content');

        tabs.forEach(tab => tab.classList.remove('active'));
        contents.forEach(content => content.classList.remove('active'));

        tabs[index].classList.add('active');
        contents[index].classList.add('active');
    }
</script>
    <script>
        function scrollToLastLogLine() {
            const logs = document.querySelectorAll('[id^="log-line-"]');
            if (logs.length > 0) {
                logs[logs.length - 1].scrollIntoView({ behavior: 'smooth' });
            }
        }
    </script>

    <script>
        function selectTextById(id) {
            const el = document.getElementById(id);
            if (!el) return;

            const range = document.createRange();
            range.selectNodeContents(el);

            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }
    </script>
}

@code {
    int tabIndex = 0;
    private bool initialized = false;

    private List<ExtendedTableInfoViewModel> tablesInfo = new List<ExtendedTableInfoViewModel>();
    private List<Table> tablesData = new List<Table>();
    private Timer timer;

    private string nameFilter = string.Empty;
    private string pendingFilterText = string.Empty;
    private Timer? debounceTimer;

    private bool isPaused = false;
    private bool showOnlySelected = false;
    private bool favoritesExpanded = false;

    private Dictionary<int, List<Table>> groupedTables =>
        tablesData
            .GroupBy(t =>
            {
                var match = tablesInfo.FirstOrDefault(x => x.Guid == t.TableInfo.Guid);
                return match?.GroupIndex ?? -1;
            }).ToDictionary(g => g.Key, g => g.ToList());

    protected override async Task OnInitializedAsync()
    {
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !initialized)
        {
            initialized = true;

            var res = await proberCacheMonitoringService.GetAllAppsTableInfoAsync();
            foreach (var re in res)
            {
                var appName = re.Item1;
                foreach (var r in re.Item2)
                {
                    var v = new ExtendedTableInfoViewModel() { ApplicationName = appName, Available = r.Available, Name = r.Name, Guid = r.Guid };
                    tablesInfo.Add(v);
                }
            }

            await LoadFavorites();

            var defaultFavorite = favorites.FirstOrDefault(f => f.IsDefault);
            if (defaultFavorite != null)
            {
                LoadFavorite(defaultFavorite); // auto-load selection
            }

            timer = new Timer(new TimerCallback((o) => UpdateTablesData()), null, 1000, 1000);
            
            StartLogWatcher();
        }
    }

    private void OnTableInfoChanged(ExtendedTableInfoViewModel? tableInfo, ChangeEventArgs e)
    {
        tableInfo.Capture = (bool)e.Value;
        // Do something with the updated forecast item
        //Console.WriteLine($"Checkbox for {tableInfo.Name} changed to {tableInfo.Available}");
    }

    private async void UpdateTablesData()
    {
        if (isPaused) 
            return;

        var local_tablesData = new List<Table>();
        var dictionary = tablesInfo.GroupBy(x => x.ApplicationName).ToDictionary(g => g.Key, g => g.ToList());

        foreach (var dict in dictionary)
        {
            if (dict.Value.Count > 0 && dict.Value.Any(x => x.Capture))
            {
                var result = await proberCacheMonitoringService.GetAppTableDataAsync(dict.Key, dict.Value.Where(x => x.Capture).Select(x => x.Guid).ToList());
                local_tablesData.AddRange(result);
            }
        }

        tablesData = local_tablesData;

        await InvokeAsync(StateHasChanged);
    }

    private void TogglePause()
    {
        isPaused = !isPaused;
    }

    private void OnNameFilterChanged(ChangeEventArgs e)
    {
        pendingFilterText = e.Value?.ToString() ?? "";

        debounceTimer?.Dispose(); // Reset the timer
        debounceTimer = new Timer(ApplyFilter, null, 1000, Timeout.Infinite);
    }

    private void ApplyFilter(object? state)
    {
        nameFilter = pendingFilterText;

        // UI update must happen on the main thread
        InvokeAsync(StateHasChanged);
    }

    private List<FavoriteMeasurement> favorites = new();
    private string newFavoriteName = "";

    private async Task SaveFavorites()
    {
        var selected = tablesInfo.Where(x => x.Capture).ToList();

        if (!selected.Any()) return;

        var fav = new FavoriteMeasurement
            {
                Name = newFavoriteName,
                SavedAt = DateTime.Now,
                SelectedTables = selected.Select(t => new ExtendedTableInfoViewModel
                {
                    ApplicationName = t.ApplicationName,
                    Name = t.Name,
                    Guid = t.Guid,
                    GroupIndex = t.GroupIndex,
                }).ToList()
            };

        favorites.Insert(0, fav);

        // Keep only the latest 10
        if (favorites.Count > 10)
            favorites = favorites.Take(10).ToList();

        await localStorage.SetItemAsync("favorites", favorites);

        newFavoriteName = "";
    }

    private async Task LoadFavorites()
    {
        favorites = await localStorage.GetItemAsync<List<FavoriteMeasurement>>("favorites") ?? new();
    }

    private void LoadFavorite(FavoriteMeasurement fav)
    {
        foreach (var table in tablesInfo)
        {
            var match = fav.SelectedTables.FirstOrDefault(x =>
                x.ApplicationName == table.ApplicationName &&
                x.Name == table.Name);

            if (match != null)
            {
                table.Capture = true;
                table.GroupIndex = match.GroupIndex;
            }
            else
            {
                table.Capture = false;
                table.GroupIndex = -1;
            }
        }
    }

    private async Task ToggleDefaultFavorite(FavoriteMeasurement fav)
    {
        // Toggle the IsDefault state
        bool wasDefault = fav.IsDefault;

        // Unset all
        foreach (var f in favorites)
        {
            f.IsDefault = false;
        }

        // If it wasn't already default, set it
        if (!wasDefault)
        {
            fav.IsDefault = true;
        }

        await localStorage.SetItemAsync("favorites", favorites);
    }

    private void ToggleFavoritesExpanded()
    {
        favoritesExpanded = !favoritesExpanded;
    }

    private async Task RemoveFavorite(FavoriteMeasurement fav)
    {
        favorites.Remove(fav);
        await localStorage.SetItemAsync("favorites", favorites);
    }

    public class FavoriteMeasurement
    {
        public string Name { get; set; } // e.g. "My Report Set 1"
        public DateTime SavedAt { get; set; }
        public List<ExtendedTableInfoViewModel> SelectedTables { get; set; } = new();
        public bool IsDefault { get; set; } = false;
    }

    public class ExtendedTableInfoViewModel
    {
        public string ApplicationName { get; set; }
        public bool Available { get; set; }
        public string Name { get; set; }
        public Guid Guid { get; set; }
        public bool Capture { get; set; }
        public int GroupIndex { get; set; } = -1; // -1 = default group
    }


    private async Task ScrollToBottom()
    {
        if (autoScrollEnabled)
            await JS.InvokeVoidAsync("scrollToLastLogLine");
    }

    private ElementReference logContainerRef;

    private bool logPopupVisible = false;
    private List<string> liveLogs = new();
    private Timer? logRefreshTimer;

    private long lastSeenLogSequence = 0;
    private long currentLogSequence = 0;
    private bool hasNewLogs => currentLogSequence > lastSeenLogSequence;
    private Timer? logCheckTimer;

    private void StartLogWatcher()
    {
        logCheckTimer = new Timer(_ =>
        {
            var seq = proberCacheMonitoringService.CurrentLogSequence;
            if (seq != currentLogSequence)
            {
                currentLogSequence = seq;
                InvokeAsync(StateHasChanged); // update the red button
            }
        }, null, 0, 1000);
    }

    private void ToggleLogPopup()
    {
        logPopupVisible = !logPopupVisible;

        if (logPopupVisible)
        {
            

            logRefreshTimer = new Timer(async _ =>
            {
                var logs = proberCacheMonitoringService.GetLogHistory();
                await InvokeAsync(async () =>
                {
                    liveLogs = logs;
                    StateHasChanged();
                    await ScrollToBottom();
                    
                    lastSeenLogSequence = proberCacheMonitoringService.CurrentLogSequence;
                });
            }, null, 0, 1000);
        }
        else
        {
            logRefreshTimer?.Dispose();
            logRefreshTimer = null;
        }
    }

    private bool autoScrollEnabled = true;

    private void ToggleAutoScroll()
    {
        autoScrollEnabled = !autoScrollEnabled;
    }

    private async Task SelectLogLine(int index)
    {
        await JS.InvokeVoidAsync("selectTextById", $"log-line-{index}");
    }
}
